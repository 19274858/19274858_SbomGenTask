import tl = require('azure-pipelines-task-lib/task');
import { exec } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';
import axios from 'axios';

class SBom {
    public packageName: string;
    public author: string;
    public licenseType: string;
    public usedVersion: string;
    public usedVersionVulnerabilityInfo: string[];
    public lastStableVersion: string | null;
    public description: string;
    public lastStableVersionVulnerabilityInfo: string[];
    public externalReferences: string;
}

class License {
    public name: string;
    public url: string;
}

interface NuGetPackageMetadata {
    version: string;
    vulnerabilities: { advisoryUrl: string }[];
}

interface NuGetPackageVersion {
    version: string;
}

class SbomJsonReader {
    async readSbomJson(sbomJsonString: string, nuGetUrl: string): Promise<SBom[]> {
        console.log(`SbomJsonReader is parsing JSON SBOM: ${sbomJsonString}`);  
        const sbomObj = JSON.parse(sbomJsonString);
        const sBomComponents = sbomObj['components'];
        const sboms: SBom[] = [];
        console.log(`sBomComponents length: ${sBomComponents.length}`);   
        for (let i = 0; i < sBomComponents.length; i++) {
            console.log(i);
            const sBomComponent = sBomComponents[i];
            const packageName = sBomComponent['name'];
            const usedVersion = sBomComponent['version'];
            const usedVersionVulnerabilityInfo = await this.getPackageVulnerabilityInfo(packageName, usedVersion, nuGetUrl);
            const lastVersion = await this.getLastStableVersion(packageName, nuGetUrl);
            const lastStableVersionVulnerabilityInfo = await this.getPackageVulnerabilityInfo(packageName, lastVersion, nuGetUrl);
            const licenseType = this.getLicenseInfo(packageName, sBomComponent);
            const description = sBomComponent['description'];
            const externalReferences = this.getExternalReferences(sBomComponent['externalReferences']);

            sboms.push({
                packageName,
                author: '',
                licenseType,
                usedVersion,
                usedVersionVulnerabilityInfo,
                lastStableVersion: lastVersion,
                lastStableVersionVulnerabilityInfo,
                description,
                externalReferences,
            });
        }
        console.log(`SbomJsonReader execution is completed. Pruced output for ${sboms.length} components`);  
        return sboms;
    }

    async getPackageVulnerabilityInfo(packageName: string, packageVersion: string | null, nuGetUrl: string): Promise<string[]> {
        try {
            console.log(`getPackageVulnerabilityInfo for ${packageName} package, version: ${packageVersion}`);
            if (!packageVersion) {
                return [];
            }
            // Get the registration base URL for the package metadata
            const indexResponse = await axios.get(`${nuGetUrl}`);
            const registrationBaseUrl = indexResponse.data.resources.find((resource: any) =>
                resource['@type'] === 'RegistrationsBaseUrl/3.6.0')['@id'];
    
            // Fetch the package metadata
            const packageMetadataUrl = `${registrationBaseUrl}${packageName.toLowerCase()}/index.json`;
            const packageMetadataResponse = await axios.get(packageMetadataUrl);
    
            // Find the version metadata
            const versionMetadata = packageMetadataResponse.data.items[0].items.find((item: any) =>
                item.catalogEntry.version === packageVersion);
    
            if (!versionMetadata) {
                return [];
            }
    
            const packageData: NuGetPackageMetadata = versionMetadata.catalogEntry;
    
            // Extract and return the vulnerability information
            const vulnerabilities = packageData.vulnerabilities.map(v => v.advisoryUrl);
            return vulnerabilities;
        } catch (error) {
            console.error('Error fetching package vulnerability info:', error);
            return [];
        }
    }

    /// <summary>
    /// Connecting to NuGet to extract last available package version
    /// </summary>
    /// <param name="packageName"></param>
    /// <param name="nuGetUrl"></param>
    /// <returns></returns>
    async getLastStableVersion(packageName: string, nuGetUrl: string): Promise<string | null> {
        try {
            // Get the registration base URL for the package metadata
            const indexResponse = await axios.get(`${nuGetUrl}`);
            const registrationBaseUrl = indexResponse.data.resources.find((resource: any) =>
                resource['@type'] === 'RegistrationsBaseUrl/3.6.0')['@id'];
    
            // Fetch the package metadata
            const packageMetadataUrl = `${registrationBaseUrl}${packageName.toLowerCase()}/index.json`;
            const packageMetadataResponse = await axios.get(packageMetadataUrl);
    
            // Extract versions
            const versions: NuGetPackageVersion[] = packageMetadataResponse.data.items[0].items.map((item: any) => ({
                version: item.catalogEntry.version
            }));
    
            // Filter stable versions and find the latest
            const stableVersions = versions
                .filter(v => !v.version.includes('-'))
                .map(v => v.version)
                .sort((a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' }));
    
            const stableVersion = stableVersions.length > 0 ? stableVersions[stableVersions.length - 1] : null;
            return stableVersion;
        } catch (error) {
            console.error('Error fetching the latest stable version:', error);
            return null;
        }
    }

    getExternalReferences(externalReferences: any[]): string {
        if (!externalReferences || externalReferences.length !== 1) {
            throw new Error('Unable to parse ExternalReferences');
        }

        const urls = externalReferences.map(x => x['url']);
        return urls.join(', ');
    }

    getLicenseInfo(name: string, sBomComponent: any): string {
        const licenses = sBomComponent['licenses'];
        if (!licenses || licenses.length !== 1) {
            throw new Error(`Unable to parse a license for ${name} component`);
        }

        const license = licenses[0]['license'];
        if (!license) {
            return 'No license information found';
        } else if (license['id']) {
            return license['id'];
        } else {
            const licenseObj: License = {
                name: license['name'],
                url: license['url']
            };
            return `${licenseObj.name}, ${licenseObj.url}`;
        }
    }
}

export async function getVulnerabilityInfo(jsonInputPath: string, sbomOutputDirectory: string, sbomOutputName: string): Promise<string | null> {
    const nuGetUrl = 'https://api.nuget.org/v3/index.json';   
    console.log(`SbomJsonReader is parsing JSON SBOM from: ${jsonInputPath}`);  
    
    fs.readFile(jsonInputPath, 'utf8', (err, data) => {
        if (err) {
            tl.setResult(tl.TaskResult.Failed, `Unable to read JSON output: ${err.message}`);
            return;
        }

        const sbomJsonString = JSON.parse(data);
        console.log(`sbomJsonString: ${sbomJsonString}`);  
        const currentLocation = __dirname;
        const currentFolder = path.dirname(currentLocation);
    
        if (!currentFolder) {
            throw new Error('Unable to get current directory');
        }
        console.log(`currentFolder: ${currentFolder}`);   
        const reader = new SbomJsonReader();
        console.log(`Starting readSbomJson, url: ${nuGetUrl}`);  
        reader.readSbomJson(sbomJsonString, nuGetUrl).then((sboms) => {
            console.log(`sboms: ${sboms.length}`);
            const sbom = JSON.stringify(sboms);
            const sbomOutputPath = path.join(sbomOutputDirectory, sbomOutputName);
            fs.writeFile(sbomOutputPath, sbom, 'utf8', (err) => {
                if (err) {
                    tl.setResult(tl.TaskResult.Failed, `Unable to write HTML output: ${err.message}`);                
                }
                console.log(`HTML report generated at: ${sbomOutputPath}`);           
            });
    
            return sbomOutputPath;
        });
    });

    return null;
}