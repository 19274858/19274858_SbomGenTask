import tl = require('azure-pipelines-task-lib/task');
import { exec } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';
import axios from 'axios';
import fetch from 'node-fetch';

const nuGetUrl = 'https://api.nuget.org/v3/index.json';

interface Vulnerability {
    advisoryUrl: string;
    severity: string;
    title: string;
    description: string;
  }
  
  interface PackageVulnerabilityInfo {
    packageId: string;
    version: string;
    vulnerabilities: Vulnerability[];
  }

class SBom {
    public packageName: string;
    public author: string;
    public licenseType: string;
    public usedVersion: string;
    public usedVersionVulnerabilityInfo: string[];
    public lastStableVersion: string | null;
    public description: string;
    public lastStableVersionVulnerabilityInfo: string[];
    public externalReferences: string;
}

class License {
    public name: string;
    public url: string;
}

interface NuGetPackageMetadata {
    version: string;
    vulnerabilities: { advisoryUrl: string }[];
}

interface NuGetPackageVersion {
    version: string;
}

class SbomJsonReader {
    async readSbomJson(sbomJsonString: string, nuGetUrl: string): Promise<SBom[]> {
        console.log(`SbomJsonReader is parsing JSON SBOM: ${sbomJsonString}`);  
        const sbomObj = JSON.parse(sbomJsonString);
        const sBomComponents = sbomObj['components'];
        const sboms: SBom[] = [];
        console.log(`sBomComponents length: ${sBomComponents.length}`);   
        for (let i = 0; i < sBomComponents.length; i++) {
            console.log(i);
            const sBomComponent = sBomComponents[i];
            const packageName = sBomComponent['name'];            
            const usedVersion = sBomComponent['version'];
            console.log(`name: ${packageName}, version: ${usedVersion}`);
            const metadata = await this.getPackageVulnerabilityMetadata(packageName, usedVersion);
            console.log(metadata);
            //const usedVersionVulnerabilityInfo = await this.getPackageVulnerabilityInfo(packageName, usedVersion, nuGetUrl);
            // const lastVersion = await this.getLastStableVersion(packageName, nuGetUrl);
            // const lastStableVersionVulnerabilityInfo = await this.getPackageVulnerabilityInfo(packageName, lastVersion, nuGetUrl);
            // const licenseType = this.getLicenseInfo(packageName, sBomComponent);
            // const description = sBomComponent['description'];
            // const externalReferences = this.getExternalReferences(sBomComponent['externalReferences']);

            // sboms.push({
            //     packageName,
            //     author: '',
            //     licenseType,
            //     usedVersion,
            //     usedVersionVulnerabilityInfo,
            //     lastStableVersion: lastVersion,
            //     lastStableVersionVulnerabilityInfo,
            //     description,
            //     externalReferences,
            // });
        }
        console.log(`SbomJsonReader execution is completed. Pruced output for ${sboms.length} components`);  
        return sboms;
    }

    async getPackageVulnerabilityInfo(packageName: string, packageVersion: string | null, nuGetUrl: string): Promise<string[]> {
        try {
            console.log(`getPackageVulnerabilityInfo for ${packageName} package, version: ${packageVersion}`);
            if (!packageVersion) {
                return [];
            }
            // Get the registration base URL for the package metadata
            const indexResponse = await axios.get(`${nuGetUrl}`);
            const registrationBaseUrl = indexResponse.data.resources.find((resource: any) =>
                resource['@type'] === 'RegistrationsBaseUrl/3.6.0')['@id'];
    
            // Fetch the package metadata
            const packageMetadataUrl = `${registrationBaseUrl}${packageName.toLowerCase()}/index.json`;
            const packageMetadataResponse = await axios.get(packageMetadataUrl);
    
            // Find the version metadata
            const versionMetadata = packageMetadataResponse.data.items[0].items.find((item: any) =>
                item.catalogEntry.version === packageVersion);
    
            if (!versionMetadata) {
                return [];
            }
    
            const packageData: NuGetPackageMetadata = versionMetadata.catalogEntry;
    
            // Extract and return the vulnerability information
            const vulnerabilities = packageData.vulnerabilities.map(v => v.advisoryUrl);
            return vulnerabilities;
        } catch (error) {
            console.error('Error fetching package vulnerability info:', error);
            return [];
        }
    }

    /// <summary>
    /// Connecting to NuGet to extract last available package version
    /// </summary>
    /// <param name="packageName"></param>
    /// <param name="nuGetUrl"></param>
    /// <returns></returns>
    async getLastStableVersion(packageName: string, nuGetUrl: string): Promise<string | null> {
        try {
            // Get the registration base URL for the package metadata
            const indexResponse = await axios.get(`${nuGetUrl}`);
            const registrationBaseUrl = indexResponse.data.resources.find((resource: any) =>
                resource['@type'] === 'RegistrationsBaseUrl/3.6.0')['@id'];
    
            // Fetch the package metadata
            const packageMetadataUrl = `${registrationBaseUrl}${packageName.toLowerCase()}/index.json`;
            const packageMetadataResponse = await axios.get(packageMetadataUrl);
    
            // Extract versions
            const versions: NuGetPackageVersion[] = packageMetadataResponse.data.items[0].items.map((item: any) => ({
                version: item.catalogEntry.version
            }));
    
            // Filter stable versions and find the latest
            const stableVersions = versions
                .filter(v => !v.version.includes('-'))
                .map(v => v.version)
                .sort((a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' }));
    
            const stableVersion = stableVersions.length > 0 ? stableVersions[stableVersions.length - 1] : null;
            return stableVersion;
        } catch (error) {
            console.error('Error fetching the latest stable version:', error);
            return null;
        }
    }

    async getPackageVulnerabilityMetadata(packageId: string, version: string): Promise<PackageVulnerabilityInfo | null> {
        
        const apiUrl = `https://api.nuget.org/v3/catalog0/data/${packageId.toLowerCase()}/${version}/index.json`;
        console.log(`Fetching package vulnerability metadata from: ${apiUrl} url`);
        try {
          const response = await fetch(apiUrl);
      
          if (!response.ok) {
            console.error(`Failed to fetch data: ${response.statusText}`);
            return null;
          }
      
        const data: any = await response.json();
      
          // Assuming that the vulnerability metadata is stored in a property named 'vulnerabilities'.
          // This would depend on the exact structure of the JSON response from the NuGet API.
          const vulnerabilities: Vulnerability[] = data.vulnerabilities || [];
          for (const vulnerability of vulnerabilities) {
            console.log(`Vulnerability: ${vulnerability}`);
          }
          return {
            packageId,
            version,
            vulnerabilities
          };
        } catch (error) {
          console.error(`Error fetching package vulnerability metadata: ${error}`);
          return null;
        }
    }
    
    getExternalReferences(externalReferences: any[]): string {
        if (!externalReferences || externalReferences.length !== 1) {
            throw new Error('Unable to parse ExternalReferences');
        }

        const urls = externalReferences.map(x => x['url']);
        return urls.join(', ');
    }

    getLicenseInfo(name: string, sBomComponent: any): string {
        const licenses = sBomComponent['licenses'];
        if (!licenses || licenses.length !== 1) {
            throw new Error(`Unable to parse a license for ${name} component`);
        }

        const license = licenses[0]['license'];
        if (!license) {
            return 'No license information found';
        } else if (license['id']) {
            return license['id'];
        } else {
            const licenseObj: License = {
                name: license['name'],
                url: license['url']
            };
            return `${licenseObj.name}, ${licenseObj.url}`;
        }
    }
}

export async function getVulnerabilityInfo(jsonInputPath: string, sbomOutputDirectory: string, sbomOutputName: string): Promise<string | null> {
    const nuGetUrl = 'https://api.nuget.org/v3/index.json';   
    console.log(`SbomJsonReader is parsing JSON SBOM from: ${jsonInputPath}`);  
    
    const sbomJsonString = fs.readFileSync(jsonInputPath, 'utf-8');   
    // console.log(`dataArray: ${sbomJsonString}`);  
    const reader = new SbomJsonReader();
    console.log(`Starting readSbomJson, url: ${sbomJsonString}`);  
    reader.readSbomJson(sbomJsonString, nuGetUrl).then((sboms) => {
        console.log(`sboms: ${sboms.length}`);
        const sbom = JSON.stringify(sboms);
        const sbomOutputPath = path.join(sbomOutputDirectory, sbomOutputName);
        fs.writeFile(sbomOutputPath, sbom, 'utf8', (err) => {
            if (err) {
                tl.setResult(tl.TaskResult.Failed, `Unable to write HTML output: ${err.message}`);                
            }
            console.log(`HTML report generated at: ${sbomOutputPath}`);           
        });

        return sbomOutputPath;
    });    
    return null;
}